---
layout: post
title: EE316 Digital Logic Design Lab 5
---

Design a Mealy sequential circuit (Figure 16-27) which investigates an input sequence
X and will produce an output of Z = 1 for any input sequence ending in 1101 or 011.
Example:
X = 0 0 1 1 0 1 1 0 1 0 1 1 0 1 0
Z = 0 0 0 1 0 1 1 0 1 0 0 1 0 1 0
Notice that the circuit does not reset to the start state when an output of Z = 1
occurs. However, your circuit should have a start state and should be provided with
a method for manually resetting the flip-flops to the start state. A minimum solution
requires six states. Design your circuit using NAND gates, NOR gates, and three D
flip-flops. Any solution which is minimal for your state assignment and uses nine or
fewer gates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and next state are correct for each input. Then,
starting in the proper initial state, determine the output sequence for each of the
following input sequences:
(1) 1 1 0 0 1 0 1 1 0 1 0 1 0 1 1 1 0 1 1 0 1 1 0 1
(2) 0 0 1 1 0 0 1 1 0 1 0 1 0 1 1 0 1 0 1 0 1 1 0 1

<img src="/files/ee316_lab_5_part1_circuit_diagram.jpg" alt="EE Lab 5 Circuit Diagram" style="width:75%;text-align:center;margin: auto;">

<img src="/files/ee316_lab_5_part1_DA.jpg" alt="EE Lab 5 DA" style="width:75%;text-align:center;margin: auto;">

<img src="/files/ee316_lab_5_part1_DB.jpg" alt="EE Lab 5 DB" style="width:75%;text-align:center;margin: auto;">

<img src="/files/ee316_lab_5_part1_DC.jpg" alt="EE Lab 5 DC" style="width:75%;text-align:center;margin: auto;">

<img src="/files/ee316_lab_5_part1_d_flip-flip_equations.jpg" alt="EE Lab 5 D Flip Flop Equations" style="width:75%;text-align:center;margin: auto;">

<img src="/files/ee316_lab_5_part1_state_table_correct.jpg" alt="EE Lab 5 State Table" style="width:75%;text-align:center;margin: auto;">

<pre>
    <code class="language-vhdl" data-lang="vhdl">
library ieee;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;

entity SM is
port(clk, rst, x: in STD_LOGIC;

	Q1, Q2, Q3, Z: out STD_LOGIC
	);
end SM;

architecture Structure of SM is
	signal Vnet_0, Vnet_1, Q1p, Vnet_2, Vnet_3, Vnet_4, DB, Vnet_5, DC, Vnet_6, 
		Q3p, Xp, XpA, XpB, XpC, XpAp, BC, XpAC, XpBCp, Q2p: STD_LOGIC;
		
	     component nand2
         port (
                 A: in STD_LOGIC;
                 B: in STD_LOGIC;
                 C: out STD_LOGIC
         );
         end component;
 
 
         component nand3
         port (
                 A: in STD_LOGIC;
                 B: in STD_LOGIC;
                 C: in STD_LOGIC;
                 D: out STD_LOGIC
         );
         end component;
         
	     component inverter
         port (
                 A: in STD_LOGIC;
                 B: out STD_LOGIC
         );
         end component;
		
		component Dflipflop 
        port (
                  CLK: in STD_LOGIC;
                  D: in STD_LOGIC;
                  SN: in STD_LOGIC;
                  RN: in STD_LOGIC;
                  Q: out STD_LOGIC;
                  QN: out STD_LOGIC
        );
        end component;
		
begin
	VHDL_Device_0: Dflipflop port map (clk, x,'1', rst, Vnet_1, Q1p);
	VHDL_Device_1: Dflipflop port map (clk, DB, '1', rst, Vnet_5, Q2p);
	VHDL_Device_2: Dflipflop port map (clk, DC, '1', rst, Vnet_6, Q3p);
	VHDL_Device_3: inverter port map (x, Xp);
	VHDL_Device_4: nand2 port map (Xp, Vnet_1, XpA);
	VHDL_Device_5: nand2 port map (Xp, Vnet_5, XpB);
	VHDL_Device_6: nand2 port map (Xp, Vnet_6, XpC);
	VHDL_Device_7: nand2 port map (Xp, Q1p, XpAp);
	VHDL_Device_8: nand2 port map (Vnet_5, Vnet_6, BC);
	VHDL_Device_9: nand2 port map (XpAp, BC, DC);
	VHDL_Device_10: nand2 port map (XpAC, XpBCp, Z);
	VHDL_Device_11: nand3 port map (XpA, XpB, XpC, DB);
	VHDL_Device_12: nand3 port map (Xp, Vnet_1, Vnet_6, XpAC);
	VHDL_Device_13: nand3 port map (Xp, Vnet_5, Q3p, XpBCp);
	Q1 <= Vnet_1;
	Q2 <= Vnet_5;
	Q3 <= Vnet_6;
end Structure;
    </code>
</pre>
